# AssetFlow - AI Coding Assistant Rules & Best Practices

## üåç CRITICAL: Language Policy

**ALL code, documentation, and user-facing text MUST be in English only.**

- ‚úÖ English variable names: `userName`, `createUser()`
- ‚úÖ English comments: `// Fetch user data`
- ‚úÖ English error messages: "User not found"
- ‚úÖ English UI labels: "Sign In", "Dashboard"
- ‚úÖ English documentation: README.md, CONTRIBUTING.md
- ‚ùå No Spanish: `nombreUsuario`, `crearUsuario()`, "Usuario no encontrado"

## üèóÔ∏è Project Architecture

### Stack
- **Backend:** Node.js + Express + Prisma ORM + PostgreSQL
- **Frontend:** React 19 + Vite + TailwindCSS
- **Auth:** JWT with bcrypt
- **Payments:** Stripe subscriptions
- **Emails:** Resend API
- **Deployment:** Railway (monorepo with 2 services)

### Multi-Tenancy
- **Shared Database, Shared Schema** approach
- Every query MUST filter by `organizationId`
- Users are isolated by organization
- Middleware: `attachOrganization` + `requireOrganization`

### Subscription System
- 3 tiers: FREE, PRO, ENTERPRISE
- Limits enforced via `checkSubscriptionLimits` middleware
- Stripe webhook handles payment events
- Email notifications for subscription changes

## üìÅ Project Structure (Refactored MVC)

```
assetflow-ticketing-platform/
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îú‚îÄ‚îÄ index.js              # Server entry point (80 lines only!)
‚îÇ   ‚îú‚îÄ‚îÄ routes/               # Express route definitions
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.routes.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ asset.routes.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ticket.routes.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ analytics.routes.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ subscription.routes.js
‚îÇ   ‚îú‚îÄ‚îÄ controllers/          # Business logic layer
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.controller.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ asset.controller.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ticket.controller.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ analytics.controller.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ subscription.controller.js
‚îÇ   ‚îú‚îÄ‚îÄ services/             # Database operations (Prisma)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.service.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ asset.service.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ticket.service.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ organization.service.js
‚îÇ   ‚îú‚îÄ‚îÄ validators/           # Input validation middleware
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.validator.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ticket.validator.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ subscription.validator.js
‚îÇ   ‚îú‚îÄ‚îÄ middleware/           # Auth, organization, subscription
‚îÇ   ‚îú‚îÄ‚îÄ utils/                # Auth helpers, email functions
‚îÇ   ‚îú‚îÄ‚îÄ config/               # Stripe configuration
‚îÇ   ‚îú‚îÄ‚îÄ prisma/               # Schema + migrations
‚îÇ   ‚îî‚îÄ‚îÄ __tests__/            # Jest unit tests
‚îî‚îÄ‚îÄ frontend/
    ‚îî‚îÄ‚îÄ src/
        ‚îú‚îÄ‚îÄ components/       # React components
        ‚îú‚îÄ‚îÄ context/          # AuthContext
        ‚îî‚îÄ‚îÄ api/              # Axios client
```

## üîí Security Best Practices

### Authentication
- Always use `authenticateToken` middleware for protected routes
- Never expose JWT secrets in code
- Hash passwords with bcrypt (10 salt rounds minimum)
- Tokens expire in 7 days
- Store tokens in localStorage (frontend)

### Authorization
- Use `requireAdmin` for admin-only endpoints
- Always attach organization context: `attachOrganization`
- Never allow cross-organization data access
- Validate all user inputs before database queries

### Data Isolation
```javascript
// ‚úÖ CORRECT: Filter by organization
const assets = await prisma.asset.findMany({
  where: { organizationId: req.organizationId }
});

// ‚ùå WRONG: Global query without org filter
const assets = await prisma.asset.findMany();
```

## üíæ Database Patterns

### Prisma Conventions
- Use transactions for multi-step operations
- Always include error handling with try-catch
- Use `include` for eager loading related data
- Use `select` to limit returned fields
- Migrations only - never use `db push` in production

### Example Query Pattern
```javascript
try {
  const ticket = await prisma.ticket.create({
    data: {
      title,
      description,
      userId: req.user.id,
      assetId: parseInt(assetId),
      organizationId: req.organizationId
    },
    include: {
      user: true,
      asset: true
    }
  });
  res.json(ticket);
} catch (error) {
  console.error('Create ticket error:', error);
  res.status(500).json({ error: 'Failed to create ticket' });
}
```

## üõ°Ô∏è Error Handling Standards

### Backend
- Always wrap async operations in try-catch
- Return descriptive error messages
- Log errors with context: `console.error('Operation error:', error)`
- Use appropriate HTTP status codes:
  - 400: Bad Request (validation errors)
  - 401: Unauthorized (missing/invalid token)
  - 403: Forbidden (insufficient permissions, limit reached)
  - 404: Not Found
  - 500: Internal Server Error

### Error Message Format
```javascript
// ‚úÖ GOOD: Descriptive and actionable
return res.status(403).json({
  error: 'Limit reached',
  message: 'Your Free plan allows up to 10 tickets. Please upgrade to add more.',
  currentCount: 10,
  limit: 10,
  tier: 'FREE'
});

// ‚ùå BAD: Generic and unhelpful
return res.status(500).json({ error: 'Error' });
```

## üé® Frontend Conventions

### Component Structure
- Functional components with hooks
- Use AuthContext for user state
- Axios interceptors for token injection
- TailwindCSS for styling (no custom CSS unless necessary)

### API Calls
```javascript
// ‚úÖ CORRECT: Use apiClient with automatic auth
import apiClient from '../api/client';

const response = await apiClient.get('/assets');

// ‚ùå WRONG: Manual fetch without auth handling
const response = await fetch('http://localhost:3000/api/assets');
```

### UI/UX Patterns
- Loading states for all async operations
- Error messages displayed to users
- Disabled buttons during submission
- Confirmation dialogs for destructive actions
- Responsive design (mobile-first)

## üì¨ Email Notifications

### When to Send
- User registration: Welcome email
- Ticket creation: Notify all admins
- Subscription changes: Confirmation email

### Email Best Practices
- Always check if `RESEND_API_KEY` is configured
- Graceful degradation if email fails (log warning, don't crash)
- Include actionable links in email body
- Use professional HTML templates

```javascript
// ‚úÖ CORRECT: Graceful degradation
if (!process.env.RESEND_API_KEY) {
  console.log('‚ö†Ô∏è  RESEND_API_KEY not configured, skipping email');
  return;
}
```

## üí≥ Stripe Integration

### Webhook Handling
- **CRITICAL:** Webhook MUST be before `express.json()`
- Use `express.raw({ type: 'application/json' })` for webhook
- Verify signature with `stripe.webhooks.constructEvent()`
- Handle events: `checkout.session.completed`, `customer.subscription.updated`, `customer.subscription.deleted`

### Checkout Flow
1. Create Stripe customer (or reuse existing)
2. Create checkout session with metadata (organizationId, tier)
3. Redirect user to Stripe
4. Handle webhook to update database
5. Send confirmation email

## üß™ Testing Standards

### Jest Configuration
- Test files: `__tests__/**/*.test.js`
- Mock external dependencies (Prisma, Stripe, Resend)
- Test utilities in isolation
- Aim for >80% coverage on critical paths

### Test Patterns
```javascript
describe('Auth Utils', () => {
  it('should hash password correctly', async () => {
    const password = 'password123';
    const hashed = await hashPassword(password);
    expect(hashed).not.toBe(password);
    expect(hashed.startsWith('$2b$')).toBe(true);
  });
});
```

## üìù Code Style

### JavaScript/JSX
- Use `const` by default, `let` when reassignment needed
- Arrow functions for callbacks
- Async/await over Promise.then()
- Destructuring for cleaner code
- Template literals over string concatenation

### Naming Conventions
- **Variables:** camelCase (`userName`, `assetCount`)
- **Functions:** camelCase (`createUser`, `fetchAssets`)
- **Components:** PascalCase (`LoginForm`, `Dashboard`)
- **Constants:** UPPER_SNAKE_CASE (`JWT_SECRET`, `MAX_RETRIES`)
- **Files:** kebab-case (`user-management.js`, `auth-context.jsx`)

### Comments
- Explain "why", not "what"
- Document complex business logic
- JSDoc for public functions
- No commented-out code in commits

## üöÄ Deployment (Railway)

### Environment Variables
**Backend:**
- `DATABASE_URL` - PostgreSQL connection
- `JWT_SECRET` - Min 32 characters
- `FRONTEND_URL` - For CORS
- `STRIPE_SECRET_KEY`, `STRIPE_WEBHOOK_SECRET`
- `STRIPE_PRO_PRICE_ID`, `STRIPE_ENTERPRISE_PRICE_ID`
- `RESEND_API_KEY`

**Frontend:**
- `VITE_API_URL` - Backend API URL

### Build Commands
- Backend: `prisma generate && prisma migrate deploy`
- Frontend: `vite build`

## üîÑ Git Workflow

### Commit Message Format
```
type(scope): description

Examples:
feat(auth): add user invitation endpoint
fix(webhook): move webhook before express.json
docs(readme): update deployment instructions
refactor(tickets): improve error handling
test(auth): add password hashing tests
```

### Branch Strategy
- `main` - Production-ready code
- `develop` - Integration branch
- `feature/*` - New features
- `fix/*` - Bug fixes

## üéØ File Organization Rules (MVC Architecture)

### When Creating New Features

Follow the **layered architecture** in this exact order:

#### 1. **Validator** (`validators/{feature}.validator.js`)
```javascript
const validateInput = (req, res, next) => {
  // Validate req.body fields
  if (!field) return res.status(400).json({ error: 'Field required' });
  next();
};
module.exports = { validateInput };
```

#### 2. **Service** (`services/{feature}.service.js`)
```javascri Architecture
- ‚ùå Don't put business logic in routes (use controllers)
- ‚ùå Don't put database queries in controllers (use services)
- ‚ùå Don't validate input in controllers (use validators)
- ‚ùå Don't create monolithic files (separate by responsibility)
- ‚ùå Don't skip the layered architecture (Route ‚Üí Validator ‚Üí Controller ‚Üí Service)

### Backend Securitypt
const { PrismaClient } = require('@prisma/client');
const prisma = new PrismaClient();

class FeatureService {
  async create(data) {
    return await prisma.feature.create({ data });
  }
}
module.exports = new FeatureService();
```

#### 3. **Controller** (`controllers/{feature}.controller.js`)
```javascript
const featureService = require('../services/feature.service');

class FeatureController {
  async create(req, res) {
    try {
      const result = await featureService.create(req.body);
      res.json(result);
    } catch (error) {
      console.error('Error:', error);
      res.status(500).json({ error: 'Failed' });
    }
  }
}
module.exports = new FeatureController();
```

#### 4. **Router** (`routes/{feature}.routes.js`)
```javascript
const express = require('express');
const router = express.Router();
const controller = require('../controllers/feature.controller');
const validator = require('../validators/feature.validator');
const { authenticateToken } = require('../middleware/auth');

router.post('/', authenticateToken, validator.validateInput, controller.create);
module.exports = router;
```

#### 5. **Register in index.js**
```javascript
const featureRoutes = require('./routes/feature.routes');
app.use('/api/features', featureRoutes);
```

### File Naming Conventions

**Backend:**
- Routes: `{module}.routes.js`
- Controllers: `{module}.controller.js`
- Services: `{module}.service.js`
- Validators: `{module}.validator.js`
- Middleware: `{name}.js` (in middleware/)
- Utils: `{name}.js` (in utils/)
- Tests: `{name}.test.js` (in __tests__/unit/)

**Frontend:**
- Components: `{Name}.jsx` (PascalCase)
- Context: `{Name}Context.jsx`
- Utils: `{name}.js` (camelCase)
### Project Documentation
- **CONTRIBUTING.md** - Complete development guide and architecture overview
- **IMPROVEMENTS.md** - Recent bug fixes and enhancements
- **TESTING_GUIDE.md** - Testing procedures and scenarios
- **MULTI_TENANCY.md** - Multi-organization architecture
- **AUTH_IMPLEMENTATION.md** - JWT authentication details
- **DATABASE_MIGRATIONS.md** - Prisma migration workflows
- **RAILWAY_DEPLOYMENT.md** - Production deployment guide

### External Documentation
- **Prisma Docs:** https://www.prisma.io/docs
- **Stripe API:** https://stripe.com/docs/api
- **React Docs:** https://react.dev
- **TailwindCSS:** https://tailwindcss.com/docs
- **Railway:** https://docs.railway.app

## üèÜ Architecture Benefits

This refactored MVC architecture provides:

‚úÖ **Scalability** - Add features without touching existing code  
‚úÖ **Maintainability** - Clear separation of concerns  
‚úÖ **Testability** - Each layer can be tested independently  
‚úÖ **Readability** - Small, focused files (50-150 lines each)  
‚úÖ **Reusability** - Services can be used by multiple controllers  
‚úÖ **Debugging** - Easy to trace issues through layers  
‚úÖ **Team Collaboration** - Multiple devs can work without conflicts  

**Before Refactoring:** 783 lines in index.js (monolithic)  
**After Refactoring:** 80 lines in index.js + 17 modular files  

---

**Remember: When in doubt, prioritize security, user experience, layered architectur

### Frontend
- ‚ùå Don't store sensitive data in localStorage (except token)
- ‚ùå Don't make API calls without error handling
- ‚ùå Don't bypass apiClient for authenticated requests
- ‚ùå Don't hardcode API URLs (use env variables)

### General
- ‚ùå Don't commit `.env` files
- ‚ùå Don't use Spanish in any code or documentation
- ‚ùå Don't skip input validation
- ‚ùå Don't ignore TypeScript errors (if added later)

## üé® UI Component Patterns

### Button States
```jsx
<button
  onClick={handleSubmit}
  disabled={loading}
  className={`btn ${loading ? 'opacity-50 cursor-not-allowed' : ''}`}
>
  {loading ? 'Processing...' : 'Submit'}
</button>
```

### Form Validation
```jsx
if (!description || !description.trim()) {
  setError('Description is required');
  return;
}
```

### Conditional Rendering
```jsx
{isAdmin && (
  <button>Admin Only Feature</button>
)}
```

## üìä Performance Considerations

- Use pagination for large datasets
- Implement debouncing for search inputs
- Lazy load heavy components
- Optimize images (use WebP when possible)
- Minimize bundle size (tree-shaking)

## üîç Code Review Checklist

Before submitting code:
- [ ] All text is in English
- [ ] Error handling implemented
- [ ] Organization filtering applied (if applicable)
- [ ] Input validation added
- [ ] Tests written (if applicable)
- [ ] No console.logs (except intentional logging)
- [ ] Environment variables used (not hardcoded)
- [ ] CORS configured correctly
- [ ] Responsive on mobile

## üìö Additional Resources

- **Prisma Docs:** https://www.prisma.io/docs
- **Stripe API:** https://stripe.com/docs/api
- **React Docs:** https://react.dev
- **TailwindCSS:** https://tailwindcss.com/docs
- **Railway:** https://docs.railway.app

---

**Remember: When in doubt, prioritize security, user experience, and English language consistency.**
